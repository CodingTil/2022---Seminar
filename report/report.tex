%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document settings
\documentclass{ACGSeminar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Own Packages
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Own Definitions
\newcommand{\comment}[1]{}

\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator*{\argmin}{arg\,min}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BibTex
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hyphenations here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hyphenation{Sa-tan-arch-aeo-li-deal-co-hell-ish}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title, Author, etc.

\begin{document}

\title{Instant Field-Aligned Meshes}

\author{Til Mohr}


\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract

\begin{abstract}
Remeshing geometries into uniform models is an essential preceding task to many geometry processing algorithms. This paper will examine the instant field-aligned remeshing algorithm presented by Jakob et al. Doing so, this article will first introduce all key concepts used in the algorithm, and will later on present,
how the authors combine these concepts to form their remeshing algorithm. This approach stands out since uses locally optimized orientation- and position-fields to compute an isotropic triangular or quad-dominant mesh that is globally aligned with a direction field. Since it accomplishes goals from global remeshing using local optimizations, the method is quite simple complexity-wise and can produce high-quality meshes in no time. To compare to this approach, this paper will also take a closer look at other meshing algorithms and will analyze the performance and quality differences in the resulting meshes.
\end{abstract}

\keywords{remeshing, triangulation, quadrangulation}
\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
\label{cha:introduction}
\section{Introduction}
\begin{itemize}
	\item	Why remeshing? $\rightarrow$ Many geometry processing algorithms (smoothing, compression, ...) benefit from isotropic remeshing \cite{surazhsky2003isotropic}. (This is where the paper fits amongst the other papers of the seminar)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Background
\section{Background and Terminology}
To fully understand how the algorithm works, we first need to understand some key concepts and techniques. This also helps us to distinguish this approach from other remeshing algorithms.

\subsection{Polygonal meshes}
In computer graphics, there are many possible ways to represent surfaces of digital geometries, such as parametric surfaces, subdivision surfaces, and polygonal meshes. In this paper, we only focus on the latter.\bigskip

A polygonal mesh is a set of polygonal faces, each representing a 2D surface embedded in 3D. Each face consists of a vertex, a 3D point, and edges connecting these vertices. The idea behind polygonal meshes is \textit{cell decomposition}: a complex digital geometry is composed of numerous simple polygonal cells \cite{bommes2013quad}. This allows for performance optimization and reduction of complexity since as an example geometrical formulas on simple polygons are often already predefined. It is very desirable to reduce the number of vertices of each polygonal face to remove complexity. Therefore, polygonal meshes with only very few vertices per face are dominant in computer graphics and geometry processing. The most common categories are triangle meshes and quad meshes. The best type of polygon for a mesh depends on its application.\bigskip

\textbf{Quad meshes} are meshes, where each cell is a quadrilateral. They have a tensor product structure, which is beneficial to many applications such as spline fitting. Because quad meshes have this mathematical benefit, many algorithms are better suited for quad meshes than triangle meshes. Hence, they play a major role in computer graphics and geometry processing \cite{bommes2013quad, chen2019quadrilateral}.\bigskip

Although the quality of a quad mesh isn't specifically defined, there are some indices of a high-quality quad mesh - depending on the application -, such as flat and square faces, and vertices of valency 4. Creating a high-quality pure-quad mesh is a quite challenging task, however. When the geometry's surface has boundaries and curvatures forcing the meshes grid, which is created by square faces, to conform to them, singularities are unavoidable. A \textbf{Singularity} in a mesh is a vertex with irregular valency, a regular valency in a quad mesh, of course, being 4 \cite{fogg2017simple,fogg2018singularities}.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=9cm]{img/Singularities.png}\par
	\end{centering}
	\caption{Singularities create pentagons or triangles in quad-dominant mesh \textit{(left)}. Can be transformed into a pure-quad mesh through a subdivision step \textit(right). \cite{jakob2015instant}}
	\label{fig:singularities}
\end{figure}

Because handling these singularities is complicated on its own, oftentimes meshing algorithms resort to quad-dominant meshes. \textbf{Quad-dominant meshes} are meshes, where the majority of faces are quadrilaterals, with some being triangles or pentagons. A quad-dominant mesh can however be converted into a pure-quad mesh through a Catmull-Clark subdivision step (\cite{catmull1978recursively}) \cite{jakob2015instant}.\bigskip

When a tensor product structure is not needed, often \textbf{triangle meshes} are used because of the reduced number of vertices in comparison to quad meshes, resulting in simplified geometrical calculations. Additionally, triangle-dominant meshes can be easily and efficiently remeshed as meshes purely of triangular faces, that are of course by nature always flat. Because of these benefits, modelling a triangle mesh from data or even scratch can be a lot easier than modelling quad meshes. As an example, 3D scans produce triangle meshes, although often very nonuniform.\bigskip

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=9cm]{img/Uniform-Mesh.png}\par
	\end{centering}
	\caption{Nonuniform mesh \textit{(left)} and its uniform counterpart after uniform remeshing \textit{(right)} \cite{alliez2008recent}.}
	\label{fig:uniform-mesh}
\end{figure}

A mesh is \textbf{uniform} when its faces are as "uniform" as possible. This means the faces are of the same size and of the same shape. Additionally, \textbf{isotropy} is an important property of meshes. A mesh is isotropic, when its faces are aligned in certain directions. So combined, an uniform and isotropic mesh consists of equilateral triangles in triangle meshes or squares in quad meshes \cite{alliez2003isotropic,surazhsky2003isotropic}. While modelling triangle meshes, it is not uncommon that the resulting meshes are very nonuniform and have many redundant faces. Algorithms performing on triangle meshes can heavily struggle under such conditions. Therefore, it is quite beneficial to simplify such meshes into uniform replicas while also minimizing face count, without losing the shape of the original geometry (figure \ref{fig:uniform-mesh}).


\subsection{Global and local remeshing}\label{global-local-remeshing}
As already stated, many meshes are created through automatic processes like 3D scanning, which do often result into low quality meshes. For many geometry processing algorithms these meshes are dissatisfactory and will result in performance and quality losses. So there is a need to reduce the complexity of these meshes, to improve their quality, and sometimes even transform them into an entirely different type of mesh. This process is called \textbf{remeshing} \cite{alliez2008recent}.\bigskip

Although there are several central issues to all remeshing techniques, one especially complex one is to find the corresponding location of a new vertex on the input mesh. This is where all remeshing techniques are categorized into two classes: Global remeshing and local remeshing \cite{botsch2007geometric,alliez2008recent}.\bigskip

\textbf{Global remeshing} tackles the correspondence problem through mesh parameterization. Mesh parameterization is the process of finding a parametric equation of the meshes surface. Since the input and output mesh should share the same surface, finding the corresponding location of a new vertex on the input mesh is quite uncomplicated, given that the parametric equation is known. Therein lies the main drawback with this global approach: Determining a parametric equation of a surface is a challenge, which can be quite computationally expensive and suffer from inaccuracy amongst other issues. However, if the input mesh was successfully parameterized, a high quality mesh can easily be produced \cite{jakob2015instant,alliez2008recent}.

To sum up, global remeshing techniques suffer from efficiency and simplicity, however can yield high quality meshes. A few great approaches to this technique are the "Mixed-Integer Quadrangulation" algorithm by Bommes et al. (\cite{bommes2009mixed}) and "Periodic Global Parameterization" by Alliez et al (\cite{ray2006periodic}).\bigskip

On the other hand there are \textbf{local remeshing} techniques. These algorithms do without global mesh parameterization and rather work directly on the surface itself. Also, instead of creating an entirely new output mesh, local remeshing algorithms locally modify the input mesh itself using topological operations, such as adding, relocating, and removing vertices. During these modifications, the vertices are always forced to rest on the surface or rather mesh. This process is highly scalable, robust and simple. However, since the process is limited to only local information at a time, it can produce solutions that aren't globally optimal. Hence, local remeshing techniques usually tend to be of lower quality than global remeshing techniques, and also introduce mesh singularities due to its locality \cite{jakob2015instant,alliez2008recent}. In the later part of this paper, we will shortly present the approach by \cite{tarini2010practical}, and later on compare it to the Instant field-aligned meshes algorithm.


\subsection{$N$-RoSy fields}\label{rosy}
In geometry a $N$-way rotational symmetry is a property a shape has when it is invariant under rotations of a multiple of $\frac{2\pi}{N}$ around a point or an axis in 2D or 3D respectively \cite{palacios2007rotational}. One can think of these symmetries as vector fields, where each point is associated with $N$ vectors, each pointing in one direction where the symmetry repeats (figure \ref{fig:n-rosy-singularities}). Hence, we also call these symmetries $N$-way rotational symmetry fields (\textbf{$N$-RoSy fields}) \cite{panozzo2012fields}.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=9cm]{img/n-Rosy-Singularity.png}\par
	\end{centering}
	\caption{A comparison between a $4$-RoSy field \textit{(left)} and its vector field \textit{(right)}. Notice how singularities (colored dots) are of zero value in the vector field. \cite{palacios2007rotational}}
	\label{fig:n-rosy-singularities}
\end{figure}

Symmetries also appear on geometrical surfaces, where they are often defined as isometric automorphism. We differ between two categories of symmetries:
\begin{itemize}
	\item	\textbf{Extrinsic} symmetries preserve euclidean distances
	\item	\textbf{Intrinsic} symmetries preserve geodesic distances
\end{itemize}
In practice though, geometries rarely have perfect symmetries on its entire surface. On most surfaces there are only local symmetries, and even they aren't always ideal. Thus, deviations must be tolerated \cite{panozzo2012fields}.\bigskip

As a side effect of imperfect symmetries $N$-RoSy fields introduce singularities. Note that these singularities can differ from singularities introduced in meshes. A singularity in $N$-RoSy fields is a point in the vector field, where the associated vector is equal to 0 (figure \ref{fig:n-rosy-singularities}) \cite{palacios2007rotational}. Briefly, they occur when the surface bends in a way that break the directions of the $N$-RoSy field. However, because of this property, they are also the points that control the topology of the field, and thus also the layout of the extracted mesh (figure \ref{fig:n-rosy-geometry}). The automatic generation of $N$-RoSy fields with optimal number and positions of singularities remains a major challenge. Methods attempting this generally cannot operate without introducing new singularities, which then appear as artifacts on the extracted meshes \cite{lai2009metric}.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=5cm]{img/n-Rosy-orientation.png} \includegraphics[width=5cm]{img/n-Rosy-Mesh.png}\par
	\end{centering}
	\caption{A $4$-RoSy orientation field calculated from a meshes surface \textit{(left)}. Note how singularities in the $4$-RoSy field (marked as colored dots), e.g. the singularity on the front right of the head, can introduce singularities in the quad-dominant output mesh \textit{(right)}, i.e. irregular vertices.}
	\label{fig:n-rosy-geometry}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Related Work
\section{Related Work}\label{related_work}
The field of meshing surfaces is an ever advancing topic. Both techniques of global and local meshing are researched extensively in the past decades. More recently, since the rise of artificial intelligence, new data-driven approaches take on this challenging problem. Since there are many respectable studies in this field, we focus our review on one approach of each technique, all of which produce quad-meshes. For a complete survey we refer the reader to \cite{bommes2013quad}.

\subsection*{Mixed-Integer Quadrangulation.}\label{MIQ}
Mixed-Integer Quadrangulation (\textit{MIQ}) by \cite{bommes2009mixed} is a global method to remeshing given triangle meshes into quad-meshes. The goal of this method is to create a global mesh parameterization (section \ref{global-local-remeshing}) which can then be used to extract a quad mesh.\bigskip

Similarly to the Instant Field-Aligned Meshes approach, MIQ first creates an orientation field on the mesh. This is done by assigning a direction to each triangle face, and then aligning them in right angles by smoothening, since the resulting mesh is intended to be a quad mesh. Creating such a smooth cross field is mathematically challenging. The authors propose to formulate this problem as a mixed-integer optimization problem, which then can be solved using a mixed-integer programming solver. Afterwards this smooth cross field can be used to cut the triangle mesh and unfold it into a 2D plane, giving way for a global mesh parameterization. Finally, using this global parameterization, a quad mesh laying on top of the 2D plane can be extracted and can then lifted back into 3D \cite{bommes2009mixed,schmidt2014towards}.

\subsection*{Practical quad mesh simplification.}\label{PQMS}
Practical quad mesh simplification (\textit{PQMS}) by \cite{tarini2010practical} is a local method to produce low complexity triangle or quad meshes starting from high complexity ones. It follows the goal to maximize the tessellation quality globally, i.e. the amount of irregular vertex valencies. Note, that mesh simplification is a related yet different topic to remeshing. Mesh simplification does not necessarily try to improve the overall quality of the mesh, it however aims to reduce the complexity, which remeshing algorithms do not fundamentally pursue.\bigskip

PQMS operates based on a preconditioned observation: An ideal, zero-complexity quad mesh is composed entirely of flat, equally sided, regular, uniform squares. Such a mesh has the property that all edges are of same length $l$, and all diagonals of each face of length $l \sqrt{2}$ \cite{tarini2010practical}.

The authors can approximate such a mesh by using local rule-based optimization operations on adjacent quad faces. The local smoothening operations include vertex/edge rotations and edge/diagonal collapses. For each group of faces these operations are prioritized by their contribution to the mesh's complexity improvement.

\subsection*{Data-Driven Interactive Quadrangulation.}\label{DDIQ}
A fairly new approach to the meshing problem is machine learning. The Data-Driven Interactive Quadrangulation method (\textit{DDIQ}) by \cite{marcias2015data} can interactively quadrangulate user-sketched patches in geometries. Similarly to previous approaches DDIQ also follows a pattern-based quadrangulation model: Given a patch on the surface, i.e. a part that has yet to be meshed, it fills in a quad mesh based on some pattern. This pattern is adaptable to the boundary constraints of the patch, i.e. the edges of the surrounding mesh \cite{marcias2015data}.

Contrarily to previous work, DDIQ does not rely on only a few predefined patterns: This approach can automatically analyze patterns in already existing quad meshes, which of course then can be used to create new ones. This allows for learning a great database of patterns, created with data from numerous manually designed meshes by artists. Fitting patterns can then be selected based on user-defined topological and geometric criteria. As a result, the quality of the filled in patches tends to increase with the amount of patterns analyzed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main Sections
\section{Method}\label{algorithm}
The following described Instant Field-Aligned Meshes algorithm is a very simple to implement local remeshing approach.

Fundamentally, it takes a graph representation of the geometry's surface as an input and outputs either a triangle-based or a quad-dominant isotropic mesh. To create this mesh, the algorithm computes 2 fields based on the input graph called orientation- and position-field respectively, of which the first one is a $N$-RoSy field (section \ref{rosy}). In order to align the mesh globally with a direction field, the orientation- and position-field are then optimized iteratively through local smoothing operations - either intrinsically or extrinsically. The output mesh can then be extracted from both fields \cite{jakob2015instant}.

% Input
\subsection{Input representation}
As mentioned, the algorithm takes the geometry's surface represented as a graph $\mathcal{G} = (\mathcal{V}, \mathcal{E})$ for an input. Each element $i \in \mathcal{V}$ is called a vertex and represents a position $v_i \in \mathbb{R}^3$ and a normal direction $n_i \in \mathbb{R}^3$. $\mathcal{E} \subset \mathcal{V} \times \mathcal{V}$, also called the set of edges, stores neighboring vertices in the graph. Depending on the original geometrical representation, it is defined differently:
\begin{itemize}
	\item	For meshes $\mathcal{E}$ is equal to the usual set of edges in the mesh.
	\item	For point clouds $(i,j) \in \mathcal{E}$, if the vertex $i$ is in the set of $K$-nearest neighbors of $j$.
\end{itemize}
We denote the neighborhood of a vertex $i$ by $\mathcal{N}(i) = \{j \in \mathcal{V} \mid (i,j) \in \mathcal{E}\}$. Additionally, there is a weight $w_{ij}$ for each edge $(i,j) \in \mathcal{E}$. These weights affect the smoothing of the orientation- and position-field later on, and can be chosen geometry-dependent or as uniform (equal to $1$).\bigskip

This simple input representation allows for many geometry representations to be used in this algorithm, as long as one can convert it into the described graph input format.

% Fields
\subsection{Fields}
Based on the input graph the algorithm now computes an $N$-RoSy field parameter-free. This field, which we will call \textbf{orientation field}, represents a set of directions on the input geometry which the edges of the output mesh should align to. To calculate this step, the algorithm locally optimizes the field's smoothness energy using integer rotations to either naturally align with the surfaces features (\textbf{intrinsic}) or to automatically snap to the geometries edges (\textbf{extrinsic}). Afterwards, this orientation field is used to calculate a positional symmetry field (PoSy field, or \textbf{position field}). Using integer translations, a parameterization is calculated for each vertex locally, and its gradient is fixed to be aligned to the orientation field. Then, the algorithm also minimizes this fields smoothness energy, either intrinsically or extrinsically \cite{jakob2015instant}.\bigskip

The following mechanisms require only a few user-defined parameters:
\begin{itemize}
	\item	Whether the output mesh should be a triangle mesh or a quad-dominant mesh: $s_o = 6$ or $s_o = 4$ resp.
	\item	The desired edge length $\rho$ in the output mesh.
	\item	Whether the fields should be calculated intrinsically or extrinsically.
\end{itemize}

\subsubsection{Orientation field}\label{orientation-field}
In the first step of the algorithm, we compute an $s_o$-RoSy field (section \ref{rosy}), which we call \textbf{orientation field}. This field will align the edges in the output mesh.\bigskip

Briefly, to compute this orientation field, we find all integer rotations of the vertices/edges in our input graph $\mathcal{G}$ and then smooth out neighboring directions in the resulting field. This process is heavily inspired by the works of \cite{bommes2009mixed,ray2008n}, however works completely locally and is thus much simpler, while still giving comparable results \cite{jakob2015instant}.

\paragraph{Symmetry group.}
In the (isotropic) output mesh each vertex has 3 or 4 directions, which the edges face in. They are aligned by this orientation field, which is calculated only on the input graph $\mathcal{G}$. Therefore, we need to assign each $i \in \mathcal{V}$ a \textit{representative} direction $o_i \in \mathbb{R}^3$. The initial value of $o_i$ has no influence in the final result, as it is used to create integer rotations around the normal direction $n_i$ of vector $i$ and will be optimized.\bigskip

\begin{wrapfigure}{r}{3cm}
	\includegraphics[width=3cm]{img/integer-rotation.png}\par
	\label{fig:integer-rotation}
\end{wrapfigure}

The authors denote the rotation matrix by angle $\theta$ about vector $n$ as $\rot(n, \theta)$. Now we can express an integer rotation of a representative vector $o$ about a fixed normal $n$ as $\mathcal{R}_{s_o}(o,n,k)$, and the set of all integer rotations of $o$ about $n$ as $\mathcal{R}_{s_o}(o,n)$:
\begin{equation*}
\begin{split}
	& \mathcal{R}_{s_o}(o,n,k) \coloneqq \rot(n, k \cdot \frac{2\pi}{s_o})o, \quad k \in \mathbb{Z} \\
	& \mathcal{R}_{s_o}(o,n) \coloneqq \{\mathcal{R}_{s_o}(o,n,0), \dots, \mathcal{R}_{s_o}(o,n,s_o-1)\}
\end{split}
\end{equation*}
So, before any optimization, the orientation field consists of all the directions in $\mathcal{R}_{s_o}(o_i, n_i)$ for every vertex $i \in \mathcal{V}$.

\paragraph{Intrinsic smoothness.}
As already mentioned, the authors based their methods on the work of \cite{ray2008n,bommes2009mixed}. Here, they propose to minimize the smoothness energy of an $N$-RoSy field by smoothening out the angle difference between nearby vectors. To do so, vectors are being folded into a common plane (figure \ref{fig:orientation-field-intrinsic-extrinsic}, top), thus maintaining the intrinsic properties of the surface \cite{jakob2015instant}.\bigskip

Since each vertex has $s_o$ representative direction vector, the authors encode this inconvenience through integer variables $k_{ij} \in \mathbb{Z}$ for each edge $(i,j) \in \mathcal{E}$ and store them in a vector $k \in \mathbb{Z}^{2 \vert \mathcal{E} \vert}$.

We can now calculate the smoothness energy of the entire $s_o$-RoSy field $O$ as:
\begin{equation}\label{eq:orientation-isotropic-energy}
	E_i(O,k) \coloneqq \sum_{i \in \mathcal{V}} \sum_{j \in \mathcal{N}(i)} \angle(o_i, \mathcal{R}_{s_o}(o_{ji}, n_i, k_{ij}))^2,
\end{equation}
where $o_{ji}$ is the representative vector $o_j$ at vertex $j$, folded into the tangent plane of vertex $v_i$. It is defined as the following:
\begin{equation*}
	o_{ji} \coloneqq \rot(n_j \times n_j, \angle(n_j, n_i))o_j
\end{equation*}
A low smoothness energy results in a more uniform, isotropic, and higher quality output mesh. So it is the goal to minimize it. In order to do so, one must find optimal values for each $o_j$ and $k_{ij}$ \cite{jakob2015instant}.\bigskip

While \cite{bommes2009mixed} proposed to minimize the smoothness energy globally, the approach this algorithm follows is a local optimization using iteration over all vertices of $\mathcal{V}$. Hence, this approach is a lot less complex than global ones, while still yielding comparable results.

Whenever the iteration visits the vertex $i$, the algorithm first determines optimal integer variables $k_{ij}$ by a brute-force search:
\begin{equation}\label{eq:orientation-intrinsic-integer}
	k_{ij} \coloneqq \argmin_{0 \leq k' < s_o} \angle(o_j, \mathcal{R}_{s_o}(o_ji, n_i, k'))
\end{equation}
By doing so, the algorithm can already find improved values for $\mathcal{R}_{s_o}(o_{ji}, n_i, k_{ij})$ in the smoothness energy equation \eqref{eq:orientation-isotropic-energy}.

Now, we can further optimize the representation direction vectors $o_i$ for each index by:
\begin{equation}\label{eq:orientation-intrinsic-vector}
\begin{split}
	& o_i \leftarrow \sum_{j \in \mathbb{N}(i)} w_{ij} \cdot \mathbb{R}_{s_o}(o_{ji}, n_i, j_{ij})\\
	& o_i \leftarrow \frac{o_i}{\Vert o_i \Vert}
\end{split}
\end{equation}
Here, the weighing $w_{ij}$ of edges can be used to guide the orientation field in certain directions at certain locations \cite{jakob2015instant}.\bigskip

The authors have found, however, that this process can be greatly improved when recalculating after visiting each edge. So we can improve the process \eqref{eq:orientation-intrinsic-vector}:
\begin{equation}
\begin{split}
	& o_i' \leftarrow w_{ij_1} \cdot \mathcal{R}_{s_o}(o_{j_1i}, n_i, k_{ij_1}), \qquad o_i \leftarrow \frac{o_i'}{\Vert o_i' \Vert}\\
	& \textrm{recompute all } k_{ij}\\
	& o_i' \leftarrow o_j' + w_{ij_2} \cdot \mathcal{R}_{s_o}(o_{j_2i}, n_i, k_{ij_2}), \qquad o_i \leftarrow \frac{o_i'}{\Vert o_i' \Vert}\\
	& \textrm{recompute all } k_{ij}\\
	& \dots
\end{split}
\end{equation}
where $j_1, j_2, \dots \in \mathcal{N}(i)$.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/orientation-field-intrinsic-extrinsic.png}\par
	\end{centering}
	\caption{Optimizing the smoothness of the orientation $s_o$-RoSy field intrinsically \textit{(top)} and extrinsically \textit{(bottom)}. \cite{jakob2015instant}}
	\label{fig:orientation-field-intrinsic-extrinsic}
\end{figure}

\paragraph{Extrinsic smoothness.}
There is a downside to this intrinsic calculation: Two vectors are always folded into a common plane. While this is efficient, we lose often desirable information about the curvature of the geometry. This behavior is illustrated in figure \ref{fig:orientation-field-illustration} The also parameter-free alternative that the authors propose can naturally align with edges in the geometry. They achieve this, by not folding two vectors into a common plane, but rather leaving them in embedded space. In addition, we can now always the symmetry vectors of both vectors \cite{jakob2015instant}.\bigskip

To do so, we must apply some modifications to the previous formulas:
The extrinsic smoothness now is:
\begin{equation}\label{eq:orientation-extrinsic-energy}
	E_e(O,k) \coloneqq \sum_{i \in \mathcal{V}} \sum_{j \in \mathcal{N}(i)} \angle(\mathcal{R}_{s_o}(o_{i}, n_i, k_{ij}, \mathcal{R}_{s_o}(o_{ji}, n_j, k_{ji}))^2,
\end{equation}
The brute force search from equation \eqref{eq:orientation-intrinsic-integer} now changes to the following:
\begin{equation}\label{eq:orientation-extrinsic-integer}
	(k_{ij}, k_{ji}) \coloneqq \argmin_{0 \leq k',k'' < s_o} \angle(\mathcal{R}_{s_o}(o_i, n_i, k'), \mathcal{R}_{s_o}(o_j, n_j, k''))
\end{equation}
Finally, we can also adapt the algorithm to optimize $o_i$ and its iterative improvement \eqref{eq:orientation-intrinsic-vector} to fit these conditions \cite{jakob2015instant}.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/orientation-field-illustration.png}\par
	\end{centering}
	\caption{Orientation fields after optimizing the smoothness energy intrinsically \textit{(left)} and extrinsically \textit{(right)}. \cite{jakob2015instant}}
	\label{fig:orientation-field-illustration}
\end{figure}

\paragraph{Singularities.}
Since the orientation field is a $N$-RoSy field, singularities can naturally occur (section \ref{rosy}). The singularities in an orientation field do affect the orientation of points in that specific location, but in the output mesh only correspond to irregular vertices \cite{jakob2015instant}.

\subsubsection{Position field}
Now that we have created and optimized the $s_o$-RoSy orientation field $O$ we can move on to the next step, which is computing the \textbf{position field}. This field is per construction perfectly aligned with the orientation field, and will specify the location of vertices on the output mesh \cite{jakob2015instant}.\bigskip

Again, this calculation is based on the works of \cite{bommes2009mixed} and \cite{ray2006periodic}. To create such a position field, previous methods proposed the computation of a global parameterization of the surface. This would allow to map the surface into 2 dimensions ($(u,v)$-parameterization), then place a grid of triangles or quadrilaterals onto that plane, and then lift the mesh back into 3 dimensional space. However, such global algorithms are complex to implement, very sensitive to topological noise, and, most importantly, do not scale with the size of the input graph well at all \cite{jakob2015instant}.\bigskip

This algorithm tackles the same problem through a local solution yet again: It computes a local parameterization for each vertex instead of finding a continuous parameterization function for the entire mesh. Similarly to the orientation field, the algorithm then locally minimizes the smoothness energy between neighboring local parameterizations. To be more specific, the smoothness between two such local parameterizations refers to the similarity between them up to integer translations \cite{jakob2015instant}.

\begin{wrapfigure}{r}{3cm}
	\includegraphics[width=3cm]{img/integer-translation.png}\par
	\label{fig:integer-translation}
\end{wrapfigure}

\paragraph{Symmetry group.}
The authors propose a simple, yet efficient encoding for the local parameterization of a vertex $i$: The parameterization's gradient is then fixated to be exactly aligned with the orientation field $o_i$ at $i$ (section \ref{orientation-field}).

Since the gradient is fixated by $o_i$, we can then encode the local parameterization of vertex $i$ in a point $p_i \in \mathbb{R}^3$. \cite{jakob2015instant} proposes this point $p_i$ to be the closest lattice point to $i$.

Let $s_p = m \cdot s_o, m \in \mathbb{N}$. The local parameterization is the of course invariant under rotations by integer multiples of $\frac{2\pi}{s_p}$ (section \ref{orientation-field}: Symmetry group.). But more importantly, it is invariant under integer translations of $\rho$ along the $s_p$ symmetry axes \cite{jakob2015instant}.\bigskip

Let $s_p$ be even. Integer translations of a position $p \in \mathbb{R}^3$ about $\rho$ and the set of all its possible integer translations are defined as:
\begin{equation*}
\begin{split}
	& \mathcal{T}_{s_p}(p,n,o,t) \coloneqq p + \rho \cdot \sum_{k=0}^{\frac{s_p}{2}-1} t_k \mathcal{R}_{s_p}(o,n,k)\\
	& \mathcal{T}_{s_p}(p,n,o) \coloneqq \{\mathcal{T}_{s_p}(p,n,o,t) \mid t \in \mathbb{Z}^{\frac{s_p}{2}}\}.
\end{split}
\end{equation*}
Since $s_p$ is even, the sum over $\frac{s_p}{2}$ terms ensures that each orientation- (or rather translation-) axis is considered once. Each integer $t_k$ then translates $p$ by $\rho$ units in the specific axis.

Given the local parameterization for each vertex, we can now define the position field $P$ as the set of all integer translations $\mathbb{T}_{s_p}(p_i, n_i, o_i)$ from each vertex $i$ \cite{jakob2015instant}.

\paragraph{Intrinsic smoothness.}
Similar to the orientation field, we again introduce new integer variables due to the ambiguity of symmetry: For each edge $(i,j) \in \mathcal{E}$ there is an integer vector $t_{ij} \in \mathbb{Z}^{\frac{s_p}{2}}$, representing integer jumps in the integer translation. For the sake of simplicity, we again store these variables in a vector $t$.\bigskip

We can now measure the intrinsic smoothness energy of the position field $P$ by:
\begin{equation*}
	E_i(P,t) \coloneqq \sum_{i \in \mathcal{V}} \sum_{j \in \mathcal{N}(i)} \Vert p_i - \mathcal{T}_{s_p}(p_{ji}, n_i, o_i, t_{ij})^2_2
\end{equation*}
$p_{ji}$ represents $p_j$ of vertex $j$ after being rotated into the tangent plane of $v_i$. It is defined as the following:
\begin{equation*}
	p_{ji} \coloneqq \rot(n_j \times n_i, \angle(n_j, n_i)) (p_j - q_{ij}) + q_{ij}
\end{equation*}
$q_{ij}$ is the point that intersects the tangent planes of both $v_i$ and $v_j$, while also having minimum distance to both points. Since this approach is intrinsic, $q_{ij}$ simply becomes the midpoint of $v_i$ and $v_j$ (both of course rotated into the same plane).\bigskip

Again, to minimize the smoothness energy, one must optimize the values for each $p_i$ and $t_{ij}$. The algorithm does this in a very similar fashion to the approach used in the optimization of the orientation field. Although this can be done intrinsically, because of the often undesired properties of intrinsic algorithms, the authors of \cite{jakob2015instant} focus on the extrinsic approach. As it is for the orientation field, the intrinsic and extrinsic approaches differ in that one does not rotate vectors into another plane, but rather leave it in three-dimensional space.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/position-field-intrinsic-extrinsic.png}\par
	\end{centering}
	\caption{Optimizing the smoothness of the position field intrinsically \textit{(top)} and extrinsically \textit{(bottom)}. \cite{jakob2015instant}}
	\label{fig:position-field-intrinsic-extrinsic}
\end{figure}

\paragraph{Extrinsic smoothness}
When the smoothness energy is optimized extrinsically, we first must recalculate $q_{ij}$. In the intrinsic approach one could define it as the midway between two vertices. In the extrinsic approach, we still must minimize the distance to $v_i$ and $v_j$, however also maintain its position on both their respective tangent planes. This is a constrained least-squares problem, but has a simple solution though:
\begin{equation*}
\begin{split}
	& q_{ij} \coloneqq \frac{1}{2}(v_i + v_j) - \frac{1}{4}(\lambda_i n_i + \lambda_j n_j),\\
	& \lambda_i \coloneqq \frac{2 \langle (n_i + \langle n_i, n_j \rangle n_j, v_j - v_i \rangle)}{1 - \langle n_i, n_j \rangle 12 + \epsilon}
\end{split}
\end{equation*}
where $\epsilon > 0$ is small real number ensuring a reasonable value for $n_i = n_j$ \cite{jakob2015instant}.\bigskip

With this position in hand, one can now optimize the integer jumps $t_{ij}$ through brute-force search over a fairly minimal set:
\begin{equation*}
	(t_{ij}, t_{ji}) \coloneqq \argmin_{t' \in Q_{ij}, t'' \in Q_{ji}} \Vert \mathcal{T}_{s_p}(p_i, n_i, o_i, t') - \mathcal{T}_{s_p}(p_j, n_j, o_j, t'') \Vert
\end{equation*}
where sets $Q_{ij}$ and $Q_{ji}$ contain the $s_p$ nearest integer translations of $q_{ij}$ to $q_{ij}$ and $q_{ji}$ to $q_{ji}$ respectively \cite{jakob2015instant}.\bigskip

Using this, we can now optimize each of the vertices representative position $p_i$ using the following iterative algorithm, similar to the orientation field optimization:
\begin{equation*}
\begin{split}
	& p_i' \leftarrow w_{ij_1} \mathcal{T}_{s_p}(p_{j_1i}, n_i, o_i, t_{ij_1}), \qquad p_i \leftarrow \frac{p_i'}{\sum_{k=1}^1 w_{ij_k}} \\
	& \textrm{recompute all } t_{ij}\\
	& p_i' \leftarrow p_i' + w_{ij_2} \mathcal{T}_{s_p}(p_{j_2i}, n_i, o_i, t_{ij_2}), \qquad p_i \leftarrow \frac{p_i'}{\sum_{k=1}^2 w_{ij_k}} \\
	& \textrm{recompute all } t_{ij}\\
	& \dots
\end{split}
\end{equation*}
where $j_1, j_2, \dots \in \mathcal{N}(i)$ \cite{jakob2015instant}.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/position-field-illustration.png}\par
	\end{centering}
	\caption{Position fields after optimizing the smoothness energy intrinsically \textit{(left)} and extrinsically \textit{(right)}. \cite{jakob2015instant}}
	\label{fig:position-field-illustration}
\end{figure}

\paragraph{Singularities.}
Through this localized approach, singularities can also appear in position fields. Here they correlate to residual integer translations over a cycle, and are not defined if an orientation singularity is already present at that location. Similar to orientation field singularities, position singularities result in an irregular vertex. However, in quad-dominant meshes, they can also produce T-junctions instead of irregular vertices \cite{jakob2015instant}.

% Multiresolution hierarchy
\subsection{Multiresolution hierarchy}
\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=\textwidth]{img/multiresolution-hierarchy.png}\par
	\end{centering}
	\caption{The iterations used in the orientation- and position-field optimizations can locally smooth their respective fields. However, they tend to get stuck in local minima. Multiresolution hierarchy is able to minimize this problem, resulting in smoother fields and fewer singularities. \cite{jakob2015instant}}
	\label{fig:multireolution-hierarchy}
\end{figure}

A main drawback the iterations used in both orientation- and position-field optimization have, is that they can get stuck in local minima. This occurs when multiple nearby vertices have very similar properties, and the iteration looping over the graphs vertices visits these vertices right after one another. If then in the internal optimization iterations (such as algorithm \eqref{eq:orientation-intrinsic-vector}) those vertices are visited right in the beginning, it can, to a certain extent, fixate these properties. Visiting other edges without similar properties can then have little to no effect on them.  This creates artifacts in the respective fields, which do not follow the geometry's surface \cite{jakob2015instant}. \bigskip

A really simple approach to tackle this is by creating a permutation of the vertices using \textbf{randomization} whenever visiting a vertex $i$.

The authors however propose the use of \textbf{multiresolution hierarchy}. Briefly speaking, it collapses neighboring vertices into "super-vertices". A more precise scheme is:
\begin{enumerate}
	\item	Processing: assign a value $A_i = 1$ to each vertex $i \in \mathcal{V}$.
	\item	Repeat, until no collapses are possible:
			\begin{enumerate}
				\item	For each edge $(i,j) \in \mathcal{E}$ assign a score:
						\begin{equation*}
							S_{ij} \coloneqq \langle n_i, n_j \rangle \cdot \min(\frac{A_i}{A_j}, \frac{A_j}{A_i})
						\end{equation*}
				\item	Iterate over $S_{ij}$ decreasingly and collapse vertices $i,j$ into the new vertex $v$, only if neither has been collapsed yet\\
						The new vertex is assigned an area of $A_v = A_i + A_j$, its other properties are determined by the area-weighted areas of all the merged vertices in $v$.
			\end{enumerate}
\end{enumerate}
The exact process is described in more detail by \cite{jakob2015instant}, which also takes inspiration from \cite{botsch2006primo}. This method can be reapplied multiple times (multiple depths), resulting in different results (figure \ref{fig:multireolution-hierarchy-depths}).

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/multiresolution-hierarchy-depths.png}\par
	\end{centering}
	\caption{An illustration of the position field after the application of multiresolution hierarchy at various depths. Notice how extreme depth values can result in lower quality results. \cite{jakob2015instant}}
	\label{fig:multireolution-hierarchy-depths}
\end{figure}

% Exporting
\subsection{Mesh extraction}
Now that we have optimized the orientation- and position-field, and thus also modified the input graph $\mathcal{G}$, one can finally export it as a mesh. To do so, the proposed algorithm takes an intermediate step and computes a new undirected graph $\mathcal{G}' = (\mathcal{V}', \mathcal{E}')$. Let $\mathcal{V}' = \{p_i \mid i \in \mathcal{V}\}$, and connect two vertices $(i,j)$, if $t_{ij}$ is unit vector-valued. These types of integer jumps are particularly interesting, since they state that $p_i$ and $p_j$ are just a single integer translation apart, approximating edges in the output mesh. Furthermore, Let $\mathcal{C} \coloneqq \{(i,j) \in \mathcal{E} \mid t_{ij} = - t_{ji}\}$. The edges in $\mathcal{C}$ have integer values, which reference the same point by integer translation \cite{jakob2015instant}.\bigskip

We can now iterate over the edges $(i,j) \in \mathcal{C}$ in increasing order of the distance $\Vert p_i - p_j \Vert$ and add those edges to $\mathcal{E}$, if neither $i$ nor $j$ are already connected by an edge. Further filtering and optimization operations can be applied to $\mathcal{G}$, as described in \cite{jakob2015instant}.

Finally, we can export $\mathcal{G}'$, which now contains position and adjacency information, as an output mesh. It only remains to detect faces in $\mathcal{G}'$, which can be done using a simple greedy algorithm. However, this approach is error-prune to harsh conditions, and can produce non-manifold outputs. To still produce manifold outputs, one can simply remove problematic vertices and edges from $\mathcal{G}'$. Note, that this will still produce artifacts in the output mesh \cite{jakob2015instant}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Results
\section{Results and Discussion}
The simplicity and locality of operations in the Instant Field-Aligned Meshes method result in incredible scalability, efficiency, and robustness compared to global approaches.

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=12cm]{img/computation-time.png}\par
	\end{centering}
	\caption{Running time comparison against several global methods for a progressive input mesh. \cite{jakob2015instant}}
	\label{fig:computation-time}
\end{figure}

Current global meshing approaches yield computation times of significant superlinear growth with increasing mesh size. In the case of MIQ (section \ref{MIQ}), this is mostly due to the more complex mixed-integer problem that comes with more vertices, i.e. more and larger constraints to the problem. Solving these increased programming problems of course takes more time \cite{jakob2015instant,bommes2009mixed}.

Similarly to other local meshing methods like PQMS (section \ref{PQMS}), IFAM also operates in linear time. This allows for great scalability, i.e. 3D models of incredible size can be easily quadrangulated (see figure \ref{fig:computation-time}). In addition, this method can be implemented parallel, further benefiting from larger input sizes \cite{jakob2015instant}.\bigskip

This great advantage in computation time does, however, come at the cost of quality. Figure \ref{fig:quality} illustrates the quality differences between the global approach MIQ, the local approach PQMS, and IFAM:

\begin{figure}[htb!]
	\begin{centering}
		\includegraphics[width=8cm]{img/quality.png}\par
	\end{centering}
	\caption{Quadrilateral meshing comparison: MIQ \cite{bommes2009mixed} (\textit{top left}), PQMS \cite{tarini2010practical} (\textit{bottom left}), IFAM (\textit{right}). \cite{jakob2015instant}}
	\label{fig:quality}
\end{figure}

In the bottom row of the figure you can see how, by making use of alignment information, the Instant Field-Aligned Meshes approach naturally snaps to shape feature, while also obtaining higher isotropy and regularity \cite{jakob2015instant}.

Compared to global approaches, IFAM lacks quality. Due to its locality, IFAM tends to create more singularities than global algorithms such as MIQ. From this comes the main point of criticism: IFAM by itself creates lots of singularities and singularity pairs in unexpected and unintended locations that simply wouldn't occur in global methods. This is a problem that has yet to be dealt with. Perhaps "messy" areas in both orientation and position field could be excluded from the output mesh, and then be filled in by pattern based patch filling such as DDIQ (section \ref{DDIQ}) as an optional post-processing step to minimize those singularity occurrences.

Furthermore, from the top row of figure \ref{fig:quality} one can see, that IFAM computes are more uniform output mesh that the global method MIQ \cite{jakob2015instant}.\bigskip

Finally, local remeshing approaches are more robust to non-manifold input meshes than global methods: Even if just some vertices are non-manifold, global meshes often fail to execute and compute an output mesh. On the other hand, due to the locality of IFAM, the algorithm is often unaware of the existence of non-manifold vertices in the input and can skip those non-manifold vertices, thus creating an output mesh with the affected areas cut out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusion
\section{Conclusion}
\begin{itemize}
	\item	Quite simple algorithm, but powerful
	\item	Parts can be separated and used individually (for example you can use the orientation field generation in other algorithms as well)
	\item	Problem of many singularities needs to be dealt with
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
\label{cha:references}
\printbibliography

\end{document}
